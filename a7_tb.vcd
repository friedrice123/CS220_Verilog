$date
	Tue Apr 11 21:52:28 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module a7_tb $end
$var wire 32 ! result [31:0] $end
$var reg 1 " clk $end
$var reg 1 # reset $end
$scope module uut $end
$var wire 1 " clk $end
$var wire 32 $ nextPC1 [31:0] $end
$var wire 32 % out1 [31:0] $end
$var wire 1 # reset $end
$var wire 5 & shamt [4:0] $end
$var wire 5 ' rt [4:0] $end
$var wire 5 ( rs [4:0] $end
$var wire 32 ) result [31:0] $end
$var wire 5 * rd [4:0] $end
$var wire 32 + out2 [31:0] $end
$var wire 6 , opcode [5:0] $end
$var wire 32 - nextPC [31:0] $end
$var wire 32 . instruction [31:0] $end
$var wire 16 / imm [15:0] $end
$var wire 6 0 funct [5:0] $end
$var reg 32 1 PC [31:0] $end
$var reg 32 2 nextPC2 [31:0] $end
$var reg 32 3 res [31:0] $end
$var reg 32 4 temp [31:0] $end
$scope module u1 $end
$var wire 32 5 PC [31:0] $end
$var wire 1 " clk $end
$var wire 1 # reset $end
$var wire 32 6 instruction [31:0] $end
$var reg 32 7 nextPC [31:0] $end
$scope module u1 $end
$var wire 32 8 address [31:0] $end
$var wire 32 9 instruction [31:0] $end
$upscope $end
$upscope $end
$scope module u2 $end
$var wire 1 " clk $end
$var wire 32 : data_in [31:0] $end
$var wire 1 ; re $end
$var wire 5 < read1 [4:0] $end
$var wire 5 = read2 [4:0] $end
$var wire 1 # reset $end
$var wire 1 > we $end
$var wire 5 ? write [4:0] $end
$var reg 32 @ data_out1 [31:0] $end
$var reg 32 A data_out2 [31:0] $end
$upscope $end
$scope module u3 $end
$var wire 32 B PC [31:0] $end
$var wire 32 C a [31:0] $end
$var wire 32 D b [31:0] $end
$var wire 32 E instruction [31:0] $end
$var wire 32 F nextPC2 [31:0] $end
$var wire 32 G result [31:0] $end
$var wire 5 H shamt [4:0] $end
$var wire 5 I rt [4:0] $end
$var wire 5 J rs [4:0] $end
$var wire 5 K rd [4:0] $end
$var wire 6 L opcode [5:0] $end
$var wire 26 M offset [25:0] $end
$var wire 16 N imm [15:0] $end
$var wire 6 O funct [5:0] $end
$var reg 32 P nextPC [31:0] $end
$var reg 32 Q nextPC1 [31:0] $end
$var reg 32 R ra [31:0] $end
$var reg 32 S temp_mem [31:0] $end
$upscope $end
$scope module u4 $end
$var wire 1 " clk $end
$var wire 32 T data_in [31:0] $end
$var wire 1 U re $end
$var wire 5 V read1 [4:0] $end
$var wire 5 W read2 [4:0] $end
$var wire 1 # reset $end
$var wire 1 X we $end
$var wire 5 Y write [4:0] $end
$var reg 32 Z data_out1 [31:0] $end
$var reg 32 [ data_out2 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx [
bx Z
bx Y
1X
bx W
bx V
0U
b0 T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
0>
bx =
bx <
1;
b1 :
bx 9
bx 8
bx 7
bx 6
b0 5
b0 4
b0 3
b0 2
b0 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
1#
0"
bx !
$end
#15
b0 $
b0 F
b0 Q
bx 3
bx T
b0 P
bx !
bx )
bx G
bx S
b100000 O
b0 H
b10 K
b1 I
b0 J
b0 L
b1000000100000 N
b10001000000100000 M
b1000000100000 /
b0 ,
b0 (
b0 <
b0 V
b1 '
b1 =
b1 W
b10 *
b10 ?
b10 Y
b0 &
b100000 0
b10001000000100000 .
b10001000000100000 6
b10001000000100000 9
b10001000000100000 E
b0 -
b0 7
b0 8
b0 B
b0 [
b0 Z
1"
#30
0"
#45
b111 +
b111 A
b111 D
b0xxxx %
b0xxxx C
b1111 @
1"
#60
0"
0#
#75
b0x $
b0x F
b1 Q
b1 P
bx !
bx )
bx G
bx S
b100011 O
b11 K
b1100000100011 N
b10001100000100011 M
b1100000100011 /
b11 *
b11 ?
b11 Y
b100011 0
b10001100000100011 .
b10001100000100011 6
b10001100000100011 9
b10001100000100011 E
b1 -
b1 7
b1 8
b1 B
b0 1
b0 5
b11111111111111111111111111111111 4
1"
#90
0"
#105
b0x0 $
b0x0 F
b10 Q
b0xxx 3
b0xxx T
b10 P
b0xxx !
b0xxx )
b0xxx G
b0xxx S
b100100 O
b100 K
b10000000100100 N
b10010000000100100 M
b10000000100100 /
b100 *
b100 ?
b100 Y
b100100 0
b10010000000100100 .
b10010000000100100 6
b10010000000100100 9
b10010000000100100 E
b10 -
b10 7
b10 8
b10 B
bx 1
bx 5
bx 4
b0x 2
1"
#120
0"
#135
b0xx $
b0xx F
b11 Q
b0x111 3
b0x111 T
b11 P
b0x111 !
b0x111 )
b0x111 G
b0x111 S
b100101 O
b101 K
b10100000100101 N
b10010100000100101 M
b10100000100101 /
b101 *
b101 ?
b101 Y
b100101 0
b10010100000100101 .
b10010100000100101 6
b10010100000100101 9
b10010100000100101 E
b11 -
b11 7
b11 8
b11 B
b0x0 2
1"
#150
0"
#165
b0xxxx00 3
b0xxxx00 T
b0xxxx00 !
b0xxxx00 )
b0xxxx00 G
b0xxxx00 S
b0 O
b10 H
b110 K
b11000010000000 N
b10011000010000000 M
b11000010000000 /
b110 *
b110 ?
b110 Y
b10 &
b0 0
b10011000010000000 .
b10011000010000000 6
b10011000010000000 9
b10011000010000000 E
b100 -
b100 7
b100 8
b100 B
b0xx 2
1"
#180
0"
#195
b0x0x $
b0x0x F
b101 Q
b0x111 3
b0x111 T
b101 P
b0x111 !
b0x111 )
b0x111 G
b0x111 S
b100101 O
b0 H
b11000000100101 N
b10011000000100101 M
b11000000100101 /
b0 &
b100101 0
b10011000000100101 .
b10011000000100101 6
b10011000000100101 9
b10011000000100101 E
b101 -
b101 7
b101 8
b101 B
1"
#210
0"
#225
b0 3
b0 T
b0 !
b0 )
b0 G
b0 S
b1000 O
b0 K
b101 L
b1000 N
b10000000000001000 M
b1000 /
b101 ,
b0 *
b0 ?
b0 Y
b1000 0
b10100000000010000000000001000 .
b10100000000010000000000001000 6
b10100000000010000000000001000 9
b10100000000010000000000001000 E
b110 -
b110 7
b110 8
b110 B
b0x0x 2
1"
#240
0"
#255
b0x000 $
b0x000 F
b1000 Q
b1000 P
b0 I
b10100 L
b1000 M
b10100 ,
b0 '
b0 =
b0 W
b1010000000000000000000000001000 .
b1010000000000000000000000001000 6
b1010000000000000000000000001000 9
b1010000000000000000000000001000 E
b111 -
b111 7
b111 8
b111 B
1"
#260
